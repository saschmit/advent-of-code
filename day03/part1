#!/usr/bin/python

from __future__ import print_function
import sys

BLANK = '.'
CENTER = 'o'
INTERSECTION = 'X'
SELF_INTERSECTION = '+'
HORIZ = '-'
VERT = '|'

COLOR_NONE = ''
COLOR_RESET = '\033[0m'
COLOR_ONE = '\033[33m'
COLOR_TWO = '\033[32m'
COLOR_BOTH = '\033[31m'

class Panel:
    def __init__(self):
        self.origin = (0, 0)
        self.panel = [ [ (CENTER, COLOR_NONE) ] ]
        self.default = (BLANK, COLOR_NONE)
    def read(self, col, row):
        try:
            if col + self.origin[0] < 0 or row + self.origin[1] < 0:
                raise IndexError('out of range')
            return self.panel[row + self.origin[1]][col + self.origin[0]]
        except IndexError:
            return self.default
    def draw(self, col, row, item):
        while row + self.origin[1] < 0:
            self.prepend_row()
        while col + self.origin[0] < 0:
            self.prepend_col()
        while row + self.origin[1] >= len(self.panel):
            self.append_row()
        while col + self.origin[0] >= len(self.panel[0]):
            self.append_col()

        self.panel[row + self.origin[1]][col + self.origin[0]] = item
    def prepend_row(self):
        self.origin = (self.origin[0], self.origin[1] + 1)
        self.panel.insert( 0, [ self.default ] * len(self.panel[0]))
    def append_row(self):
        self.panel.append( [ self.default ] * len(self.panel[0]) )
    def prepend_col(self):
        self.origin = (self.origin[0] + 1, self.origin[1])
        for y in xrange(len(self.panel)):
            self.panel[y].insert(0, self.default)
    def append_col(self):
        for y in xrange(len(self.panel)):
            self.panel[y].append(self.default)
    def __str__(self):
        out = BLANK * (len(self.panel[0]) + 2) + '\n'
        for y in xrange(len(self.panel)):
            out += BLANK + "".join(map(lambda t: t[1] + t[0] + COLOR_RESET, self.panel[y])) + BLANK + "\n"
        out += BLANK * (len(self.panel[0]) + 2)
        return out

def combine(old, new):
    if old[1] == COLOR_NONE:
        if old[0] == CENTER:
            return old
        else:
            return new
    elif old[1] == COLOR_ONE and new[1] == COLOR_TWO or old[1] == COLOR_TWO and new[1] == COLOR_ONE:
        return (INTERSECTION, COLOR_BOTH)
    else:
        return (SELF_INTERSECTION, old[1])

def apply_wire(panel, color, path):
    out_list = []
    start = (0, 0)
    for step in path:
        direction = step[0]
        count = int(step[1:])
        for i in xrange(count + 1):
            if direction == 'U':
                point = (start[0], start[1] - i)
                shape = VERT
            elif direction == 'D':
                point = (start[0], start[1] + i)
                shape = VERT
            elif direction == 'L':
                point = (start[0] - i, start[1])
                shape = HORIZ
            elif direction == 'R':
                point = (start[0] + i, start[1])
                shape = HORIZ

            cell = combine(panel.read(point[0], point[1]), (shape, color))
            if cell[0] == INTERSECTION:
                out_list.append((point[0], point[1]))
            panel.draw(point[0], point[1], cell)

            if i == count:
                start = point

    return out_list


panel = Panel()

paths = map(lambda s: s.split(','), open(sys.argv[1]).read().strip().split('\n'))
print(paths)

apply_wire(panel, COLOR_ONE, paths[0])
intersections = apply_wire(panel, COLOR_TWO, paths[1])

print(panel)

part1 = min(map(sum, map(lambda t: (abs(t[0]), abs(t[1])), intersections)))
print(part1)
