#!/usr/bin/python

from __future__ import print_function
import intcode
import sys

TILE_DROID_GOAL = -3
TILE_DROID = -2
TILE_UNKNOWN = -1
TILE_WALL = 0
TILE_EMPTY = 1
TILE_OXYGEN = 2

PIXMAP = {
    TILE_DROID_GOAL: "!",
    TILE_DROID: "D",
    TILE_UNKNOWN: "?",
    TILE_WALL: "#",
    TILE_EMPTY: ".",
    TILE_OXYGEN: "O",
}

DIR = {1:'N', 2:'S', 3:'W', 4:'E'}

class SparseGrid:
    def __init__(self):
        self.grid = {}
        self.min_x = 0
        self.min_y = 0
        self.max_x = 0
        self.max_y = 0

    def set(self, x, y, tile):
        self.min_x = min(self.min_x, x)
        self.min_y = min(self.min_y, y)
        self.max_x = max(self.max_x, x)
        self.max_y = max(self.max_y, y)
        self.grid[(x, y)] = tile

    def at(self, x, y):
        try:
            return self.grid[(x, y)]
        except KeyError:
            return TILE_UNKNOWN

    def get_height(self):
        return self.max_y - self.min_y + 1

    def get_width(self):
        return self.max_x - self.min_x + 1

    def get_cell_count(self):
        return len(self.grid)

    def __str__(self):
        out = ""
        for y in xrange(self.min_y, self.max_y+1):
            for x in xrange(self.min_x, self.max_x+1):
                out += PIXMAP[self.at(x, y)]
            out += '\n'
        return out.rstrip()

class OxygenDroid:
    def __init__(self, grid):
        self.grid = grid

        self.x = 0
        self.y = 0
        self.dir = None
        self.stack = [ (0,0) ]
    def get_out_fn(self):
        def out(val):
            if val == TILE_EMPTY:
                if self.dir == 1: # N
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x, self.y - 1, TILE_DROID)
                    self.y -= 1
                elif self.dir == 2: # S
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x, self.y + 1, TILE_DROID)
                    self.y += 1
                elif self.dir == 3: # W
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x - 1, self.y, TILE_DROID)
                    self.x -= 1
                elif self.dir == 4: # E
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x + 1, self.y, TILE_DROID)
                    self.x += 1
            elif val == TILE_WALL:
                if self.dir == 1: # N
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y - 1, TILE_WALL)
                elif self.dir == 2: # S
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y + 1, TILE_WALL)
                elif self.dir == 3: # W
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x - 1, self.y, TILE_WALL)
                elif self.dir == 4: # E
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x + 1, self.y, TILE_WALL)
            elif val == TILE_OXYGEN:
                if self.dir == 1: # N
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x, self.y - 1, TILE_DROID_GOAL)
                    self.y -= 1
                elif self.dir == 2: # S
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x, self.y + 1, TILE_DROID_GOAL)
                    self.y += 1
                elif self.dir == 3: # W
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x - 1, self.y, TILE_DROID_GOAL)
                    self.x -= 1
                elif self.dir == 4: # E
                    assert self.grid.at(self.x, self.y) == TILE_DROID
                    self.grid.set(self.x, self.y, TILE_EMPTY)
                    self.grid.set(self.x + 1, self.y, TILE_DROID_GOAL)
                    self.x += 1

            # Adjust stack to account for any movement above
            here = (self.x, self.y)
            if here != self.stack[-1]:
                self.stack.append(here)

        return out
    def get_in_fn(self):
        def in_fn():
            def apply_dir(pos, direction):
                if direction == 1: # N
                    return (pos[0], pos[1] - 1)
                elif direction == 2: # S
                    return (pos[0], pos[1] + 1)
                elif direction == 3: # W
                    return (pos[0] - 1, pos[1])
                elif direction == 4: # E
                    return (pos[0] + 1, pos[1])
                raise ValueError("Invalid direction {}".format(direction))

            if self.grid.at(self.x, self.y) == TILE_DROID_GOAL:
                raise RuntimeError("Found it at ({},{}) with {} steps".format(self.x, self.y, len(self.stack)-1))

            sys.stdout.write("\x1B[2J")
            print(self.grid)

            here = self.stack[-1]

            # Find the first direction that we haven't explored yet
            for direction in (1, 2, 3, 4):
                pos = apply_dir(here, direction)
                if TILE_UNKNOWN == self.grid.at(pos[0], pos[1]):
                    # Record which way we're going
                    self.dir = direction
                    # ...and go that way
                    return direction

            # If we've already explored every direction from here, backtrack
            self.stack.pop()

            # Figure out which way that is...
            for direction in (1, 2, 3, 4):
                pos = apply_dir(here, direction)
                if self.stack[-1] == pos:
                    # Record which way we're going
                    self.dir = direction
                    # ...and go that way
                    return direction

            # This shouldn't be possible...
            assert False
        return in_fn

grid = SparseGrid()
grid.set(0,0,TILE_DROID)
droid = OxygenDroid(grid)

pgm = intcode.load_pgm('input')
try:
    intcode.run_pgm(pgm, droid.get_in_fn(), droid.get_out_fn())
except RuntimeError as rte:
    print(rte)
